{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"All the code herein can also be found in the "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/automerge\/contaaacts"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Let’s imagine we’re building a simple collaborative address book with a structure similar to the following JSON:"}]},{"type":"codeListing","syntax":"json","code":["{","    \"contacts\": [","        {","            \"name\": \"Alice\",","            \"email\": \"alice@example.com\"","        },","        {","            \"name\": \"Bob\",","            \"email\": \"bob@example.com\"","        }","    ]","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"We’re going to build a simple CLI application called "},{"type":"codeVoice","code":"contaaacts"},{"type":"text","text":" for collaborating on an address book. Here’s what we want to be able to do:"}]},{"type":"codeListing","syntax":"bash","code":["# create a new address book","contaaacts create .\/friends","","# Add a new contact","contaaacts add .\/friends 'Alice' 'alice@example.com'","","# List the contents of the address book","contaaacts list .\/friends","","# Modify a contact","contaaacts update .\/friends alice --email 'alice2@example.com'","","# merge with another version of the address book and output to a new file","contaaacts merge .\/friends .\/otherfriends .\/merged","","# provide a sync server for other peers to sync with on localhost:9090","contaaacts serve .\/friends localhost 9090","","# sync with a contaaacts server running at localhost:9090 and save the result","contaaacts sync .\/friends localhost 9090"]},{"anchor":"Setup","level":2,"type":"heading","text":"Setup"},{"type":"paragraph","inlineContent":[{"type":"text","text":"We’re creating a simple command line application, we’ll have a single file called "},{"type":"codeVoice","code":"Contaaacts.swift"},{"type":"text","text":" where we parse and dispatch arguments. No error handling of any kind because this is an example. As we go through the rest of this guide we’ll fill in the implementations of the handlers."}]},{"type":"codeListing","syntax":null,"code":["@main","struct Contaaacts {","    public static func main() {","        let args = CommandLine.arguments","        switch args[1] {","        case \"create\":","            create(filename: args[2])","        case \"add\":","            add(filename: args[2], name: args[4], email: args[6])","        case \"list\":","            list(filename: args[2])","        case \"update\":","            update(filename: args[2], contact: args[4], newEmail: args[6])","        case \"merge\":","            merge(filename1: args[2], filename2: args[3], out: args[4])","        case \"serve\":","            serve(filename: args[2], port: args[3])","        case \"sync\":","            sync(filename: args[2], server: args[3], port: args[4])","        default:","            print(\"unknown command\")","        }","    }","}","","func create(filename: String) {","}","","func add(filename: String, name: String, email: String) {","}","","func list(filename: String) {","}","","func update(filename: String, contact: String, newEmail: String) {","}","","func merge(filename1: String, filename2: String, out: String) {","}","","func serve(filename: String, port: String) {","}","","func sync(server: String) {","}"]},{"anchor":"Creating-the-address-book","level":2,"type":"heading","text":"Creating the address book"},{"type":"paragraph","inlineContent":[{"type":"text","text":"To create an address book we just need to create an automerge document with an empty "},{"type":"codeVoice","code":"contacts"},{"type":"text","text":" array in it. This is conceptually simple but there’s a wrinkle, which we refer to as the “initial data” problem. Once we’ve explained the problem, the approach we take will make more sense."}]},{"anchor":"The-initial-data-problem","level":3,"type":"heading","text":"The “initial data” problem"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Automerge documents contain “objects”, which are maps, lists, or text objects. These objects have an ID ("},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.automerge.Automerge\/documentation\/Automerge\/ObjId"},{"type":"text","text":"). Every automerge document contains a “root” ID ("},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.automerge.Automerge\/documentation\/Automerge\/ObjId\/ROOT"},{"type":"text","text":")which is a map, any time you create a new object in an automerge document the new object has an ID you use to refer to it. The reason you need to know this is because the IDs which automerge generates are used to determine how to merge documents, this means that for two documents with similar structure to merge in the way we expect, they need to share a history."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Let’s make this a bit more concrete. We are building a contact book application, the core data structure is a list of contacts under the "},{"type":"codeVoice","code":"contacts"},{"type":"text","text":" key in the document. The merge behaviour we want is that when two nodes concurrently add contacts to the contact book, they end up in the same sequence. In terms of the automerge data model then, the "},{"type":"codeVoice","code":"contacts"},{"type":"text","text":" key is a property in the root object which contains a list object. The list has an ID - obtained by calling "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.automerge.Automerge\/documentation\/Automerge\/Document\/putObject(obj:key:ty:)"},{"type":"text","text":" with "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.automerge.Automerge\/documentation\/Automerge\/ObjId\/ROOT"},{"type":"text","text":", "},{"type":"codeVoice","code":"\"contacts\""},{"type":"text","text":", and "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.automerge.Automerge\/documentation\/Automerge\/ObjType\/List"},{"type":"text","text":". For concurrent insertions into this list to merge, we want all insertions to reference the same "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.automerge.Automerge\/documentation\/Automerge\/ObjId"},{"type":"text","text":" for the list, but every time you call "},{"type":"codeVoice","code":"putObject"},{"type":"text","text":" you get a new object ID. What this means is that every node needs to share a basic skeleton document which already has an empty "},{"type":"codeVoice","code":"\"contacts\""},{"type":"text","text":" list in it."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"We are very much aware that this is not a good developer experience and we are thinking about ways to make this easier. See "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/automerge\/automerge\/issues\/528"}]}],"type":"aside","name":"Note"},{"anchor":"Generating-a-skeleton-document","level":3,"type":"heading","text":"Generating a skeleton document"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The easiest way to have every peer start from a shared history is to use the automerge command line tools (installable by using "},{"type":"codeVoice","code":"cargo install automerge-cli"},{"type":"text","text":") to generate an automerge document from a JSON skeleton, and then including the bytes of this document as a resource in the application bundle."}]},{"type":"codeListing","syntax":null,"code":["# generate the skeleton  document","echo '{\"contacts\": []}' | automerge import > skeleton"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can verify the structure of the document by doing "},{"type":"codeVoice","code":"automerge export skeleton"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"We bundle the "},{"type":"codeVoice","code":"skeleton"},{"type":"text","text":" as a resource in the application, see the demo repository for details."}]},{"anchor":"Implementing-create","level":3,"type":"heading","text":"Implementing `create`"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now that we have the skeleton document, implementing "},{"type":"codeVoice","code":"\"create\""},{"type":"text","text":" is quite simple, we just output the contents of the bundled resource."}]},{"type":"codeListing","syntax":null,"code":["func create(filename: String) {","    let skeletonUrl = Bundle.module.url(forResource: \"skeleton\", withExtension: \"\")!","    let data = try! Data(contentsOf: skeletonUrl)","    let output = URL(fileURLWithPath: filename)","    try! data.write(to: output)","}"]},{"anchor":"Adding-a-contact","level":2,"type":"heading","text":"Adding a contact"},{"type":"paragraph","inlineContent":[{"type":"text","text":"To add a contact we need to load the contents of the address book, then insert an "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.automerge.Automerge\/documentation\/Automerge\/ObjType\/Map"},{"type":"text","text":" into the "},{"type":"codeVoice","code":"contacts"},{"type":"text","text":" list. Like so:"}]},{"type":"codeListing","syntax":null,"code":["func add(filename: String, name: String, email: String) {","","    \/\/ Load the data from the filesyste","    let bytes = try! Data(contentsOf: URL(fileURLWithPath: filename))","    let document = try! Document([UInt8](bytes))","    ","    \/\/ Find the contacts list in the document","    let contacts: ObjId","    switch try! document.get(obj: ObjId.ROOT, key: \"contacts\")! {","    case .Object(let id, _):","        contacts = id","    default:","        fatalError(\"contacts was not a list\")","    }","","    \/\/ Insert a new map for the new contact at the end of the contacts list","    let lastIndex = try! document.length(obj: contacts)","    let newContact = try! document.insertObject(obj: contacts, index: lastIndex, ty: .Map)","\/\/ Set the name to a text field","    let nameText = try! document.putObject(obj: newContact, key: \"name\", ty: .Text)","    try! document.spliceText(obj: nameText, start:0, delete:0, value: name)","","    \/\/ Set the email to a text field","    let emailText = try! document.putObject(obj: newContact, key: \"email\", ty: .Text)","    try! document.spliceText(obj: emailText, start:0, delete:0, value: email)","","    \/\/ now save the document to the filesystem","    let savedBytes = document.save()","    let data = Data(bytes: savedBytes, count:savedBytes.count)","    let output = URL(fileURLWithPath: filename)","    try! data.write(to: output)","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that we are using text objects to represent the name and email fields. Automerge does have a primitive string type ("},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.automerge.Automerge\/documentation\/Automerge\/ScalarValue\/String(_:)"},{"type":"text","text":") but it’s generally best to use text. There’s very little extra cost to a text object and text objects support concurrent edits."}]},{"anchor":"Listing-contacts","level":2,"type":"heading","text":"Listing contacts"},{"type":"paragraph","inlineContent":[{"type":"text","text":"To list contacts we iterate over each value in the contacts list, printing them out."}]},{"type":"codeListing","syntax":null,"code":["func list(filename: String) {","    let bytes = try! Data(contentsOf: URL(fileURLWithPath: filename))","    let document = try! Document([UInt8](bytes))","    let contacts: ObjId","    switch try! document.get(obj: ObjId.ROOT, key: \"contacts\")! {","    case .Object(let id, _):","        contacts = id","    default:","        fatalError(\"contacts was not a list\")","    }","","    for value in try! document.values(obj: contacts) {","        switch value {","        case .Object(let contact, .Map):","            let nameId: ObjId","            switch try! document.get(obj: contact, key: \"name\")! {","            case .Object(let id, .Text):","                nameId = id","            default:","                fatalError(\"contact name was not a text object\")","            }","","            let emailId: ObjId","            switch try! document.get(obj: contact, key: \"email\")! {","            case .Object(let id, .Text):","                emailId = id","            default:","                fatalError(\"contact email was not a text object\")","            }","","            let name = try! document.text(obj: nameId)","            let email = try! document.text(obj: emailId)","            print(\"\\(name): \\(email)\")","        default:","            fatalError(\"unexpected value in contacts\")","        }","    }","}"]},{"anchor":"Updating-a-contact","level":2,"type":"heading","text":"Updating a contact"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here we load the document, loop over the contacts in the "},{"type":"codeVoice","code":"contacts"},{"type":"text","text":" list, and if we find a matching name we update the email."}]},{"type":"codeListing","syntax":null,"code":["func update(filename: String, contact: String, newEmail: String) {","    let bytes = try! Data(contentsOf: URL(fileURLWithPath: filename))","    let document = try! Document([UInt8](bytes))","    let contacts: ObjId","    switch try! document.get(obj: ObjId.ROOT, key: \"contacts\")! {","    case .Object(let id, _):","        contacts = id","    default:","        fatalError(\"contacts was not a list\")","    }","","    var found = false","    for value in try! document.values(obj:contacts) {","        switch value {","        case .Object(let contactId, .Map):","            let nameId: ObjId","            switch try! document.get(obj: contactId, key: \"name\")! {","            case .Object(let id, .Text):","                nameId = id","            default:","                fatalError(\"contact name was not a text object\")","            }","","            let name = try! document.text(obj: nameId)","            if name == contact.trimmingCharacters(in: .whitespacesAndNewlines) {","                found = true","                let newEmailId = try! document.putObject(obj: contactId, key: \"email\", ty: .Text)","                try! document.spliceText(obj:newEmailId, start:0, delete:0, value: newEmail)","                break;","            }","        default:","            continue","        } }","    if !found {","        fatalError(\"contact \\(contact) not found\")","    }","","    \/\/ now save the document to the filesystem","    let savedBytes = document.save()","    let data = Data(bytes: savedBytes, count:savedBytes.count)","    let output = URL(fileURLWithPath: filename)","    try! data.write(to: output)","}"]},{"anchor":"Merging-address-books","level":2,"type":"heading","text":"Merging address books"},{"type":"codeListing","syntax":null,"code":["func merge(filename1: String, filename2: String, out: String) {","    let leftBytes = try! Data(contentsOf: URL(fileURLWithPath: filename1))","    let left = try! Document([UInt8](leftBytes))","","    let rightBytes = try! Data(contentsOf: URL(fileURLWithPath: filename2))","    let right = try! Document([UInt8](rightBytes))","","    try! left.merge(other: right)","    let savedBytes = left.save()","    let data = Data(bytes: savedBytes, count:savedBytes.count)","    let output = URL(fileURLWithPath: out)","    try! data.write(to: output)","}"]},{"anchor":"Sync","level":2,"type":"heading","text":"Sync"},{"type":"paragraph","inlineContent":[{"type":"text","text":"There’s quite a bit of ceremony involved in network programming in Swift, so we don’t repeat the code here, see the demo for the gory details."}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"identifier":{"url":"doc:\/\/org.automerge.Automerge\/documentation\/Automerge\/AddressBookExample","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Building a CLI address book application using automerge."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Address Book Example","role":"article","modules":[{"name":"Automerge"}]},"hierarchy":{"paths":[["doc:\/\/org.automerge.Automerge\/documentation\/Automerge"]]},"seeAlsoSections":[{"title":"Essentials","identifiers":["doc:\/\/org.automerge.Automerge\/documentation\/Automerge\/Document"],"generated":true}],"references":{"doc://org.automerge.Automerge/documentation/Automerge/ObjId/ROOT":{"role":"symbol","title":"ROOT","fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"kind":"keyword","text":"let"},{"kind":"text","text":" "},{"kind":"identifier","text":"ROOT"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"ObjId","preciseIdentifier":"s:9Automerge5ObjIdV"}],"abstract":[],"identifier":"doc:\/\/org.automerge.Automerge\/documentation\/Automerge\/ObjId\/ROOT","kind":"symbol","type":"topic","url":"\/documentation\/automerge\/objid\/root"},"doc://org.automerge.Automerge/documentation/Automerge":{"role":"collection","title":"Automerge","abstract":[{"type":"text","text":"A library which provides fast implementations of several different CRDTs, a compact compression format for these CRDTs, and a sync protocol for efficiently transmitting those changes over the network."}],"identifier":"doc:\/\/org.automerge.Automerge\/documentation\/Automerge","kind":"symbol","type":"topic","url":"\/documentation\/automerge"},"doc://org.automerge.Automerge/documentation/Automerge/Document/putObject(obj:key:ty:)":{"role":"symbol","title":"putObject(obj:key:ty:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"putObject"},{"kind":"text","text":"("},{"kind":"externalParam","text":"obj"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"ObjId","preciseIdentifier":"s:9Automerge5ObjIdV"},{"kind":"text","text":", "},{"kind":"externalParam","text":"key"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"String","preciseIdentifier":"s:SS"},{"kind":"text","text":", "},{"kind":"externalParam","text":"ty"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"ObjType","preciseIdentifier":"s:9Automerge7ObjTypeO"},{"kind":"text","text":") "},{"kind":"keyword","text":"throws"},{"kind":"text","text":" -> "},{"kind":"typeIdentifier","text":"ObjId","preciseIdentifier":"s:9Automerge5ObjIdV"}],"abstract":[{"type":"text","text":"Set or update "},{"type":"codeVoice","code":"key"},{"type":"text","text":" in map "},{"type":"codeVoice","code":"obj"},{"type":"text","text":" to a new instance of "},{"type":"codeVoice","code":"ty"}],"identifier":"doc:\/\/org.automerge.Automerge\/documentation\/Automerge\/Document\/putObject(obj:key:ty:)","kind":"symbol","type":"topic","url":"\/documentation\/automerge\/document\/putobject(obj:key:ty:)"},"doc://org.automerge.Automerge/documentation/Automerge/ScalarValue/String(_:)":{"role":"symbol","title":"ScalarValue.String(_:)","fragments":[{"kind":"keyword","text":"case"},{"kind":"text","text":" "},{"kind":"identifier","text":"String"},{"kind":"text","text":"("},{"kind":"typeIdentifier","text":"String","preciseIdentifier":"s:SS"},{"kind":"text","text":")"}],"abstract":[],"identifier":"doc:\/\/org.automerge.Automerge\/documentation\/Automerge\/ScalarValue\/String(_:)","kind":"symbol","type":"topic","url":"\/documentation\/automerge\/scalarvalue\/string(_:)"},"doc://org.automerge.Automerge/documentation/Automerge/ObjId":{"role":"symbol","title":"ObjId","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"ObjId"}],"abstract":[],"identifier":"doc:\/\/org.automerge.Automerge\/documentation\/Automerge\/ObjId","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ObjId"}],"url":"\/documentation\/automerge\/objid"},"doc://org.automerge.Automerge/documentation/Automerge/Document":{"role":"symbol","title":"Document","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"Document"}],"abstract":[{"type":"text","text":"The entry point to automerge, a "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.automerge.Automerge\/documentation\/Automerge\/Document"},{"type":"text","text":" presents a key\/value interface to"},{"type":"text","text":" "},{"type":"text","text":"the data it contains; as well as methods for loading and saving documents, and"},{"type":"text","text":" "},{"type":"text","text":"taking part in the sync protocol."}],"identifier":"doc:\/\/org.automerge.Automerge\/documentation\/Automerge\/Document","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Document"}],"url":"\/documentation\/automerge\/document"},"https://github.com/automerge/automerge/issues/528":{"title":"this issue","titleInlineContent":[{"type":"text","text":"this issue"}],"type":"link","identifier":"https:\/\/github.com\/automerge\/automerge\/issues\/528","url":"https:\/\/github.com\/automerge\/automerge\/issues\/528"},"doc://org.automerge.Automerge/documentation/Automerge/ObjType/List":{"role":"symbol","title":"ObjType.List","fragments":[{"kind":"keyword","text":"case"},{"kind":"text","text":" "},{"kind":"identifier","text":"List"}],"abstract":[],"identifier":"doc:\/\/org.automerge.Automerge\/documentation\/Automerge\/ObjType\/List","kind":"symbol","type":"topic","url":"\/documentation\/automerge\/objtype\/list"},"https://github.com/automerge/contaaacts":{"title":"demo repository","titleInlineContent":[{"type":"text","text":"demo repository"}],"type":"link","identifier":"https:\/\/github.com\/automerge\/contaaacts","url":"https:\/\/github.com\/automerge\/contaaacts"},"doc://org.automerge.Automerge/documentation/Automerge/ObjType/Map":{"role":"symbol","title":"ObjType.Map","fragments":[{"kind":"keyword","text":"case"},{"kind":"text","text":" "},{"kind":"identifier","text":"Map"}],"abstract":[],"identifier":"doc:\/\/org.automerge.Automerge\/documentation\/Automerge\/ObjType\/Map","kind":"symbol","type":"topic","url":"\/documentation\/automerge\/objtype\/map"}}}